## HTTP

### Http简介

HTTP协议用于定义客户端与web服务器通迅的格式。
HTTP是hypertext transfer protocol（超文本传输协议）的简写，它是TCP/IP协议的一个应用层协议

### Http版本

HTTP协议的版本：HTTP/1.0、HTTP/1.1，其中1.0一次请求发起一次连接，响应过后连接自动断开。1.1里每次请求响应后连接将保持一段时间，这段时间内可以再执行请求响应。

### Http工作原理

HTTP使用请求-响应的方式进行传输，一个请求对应一个响应，并且请求只能是由客户端发起的。

HTTP默认端口号为80，但是你也可以改为8080或者其他端口。

**HTTP三点注意事项：**

- HTTP是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。
- HTTP是媒体独立的：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。
- HTTP是无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快

### Http请求

一个http请求包含一个请求行，若干请求头（消息头），若干请求体，**下面是一个请求报文的格式：**

![](https://www.runoob.com/wp-content/uploads/2013/11/2012072810301161.png)

#### 请求行

GET /books/java.html HTTP/1.1  请求方式 请求的资源名 所遵循的协议
请求行中的GET称之为请求方式，请求方式有：POST、GET、HEAD、OPTIONS、DELETE、TRACE、PUT，常用的有： GET、 POST

用户如果没有设置，默认情况下浏览器向服务器发送的都是get请求，例如在浏览器直接输地址访问，点超链接访问等都是get，用户如想把请求方式改为post，可通过更改表单的提交方式实现。	

其中GET方式在请求资源的URL后跟“？参数名=参数值&参数名=。。。”方式传递参数，传输的数据内容最大为1K
其中POST方式在请求实体中传输数据
除了用Form表单明确用method指定用post方式提交数据以外，其他的方式都是GET提交方式

####  请求头((request)

	Accept: text/html,image/*    客户端可以接受的数据类型
	Accept-Charset: ISO-8859-1	客户端接受数据需要使用的字符集编码
	Accept-Encoding: gzip,compress 客户端可以接受的数据压缩格式
	Accept-Language: en-us,zh-cn  可接受的语言环境
	Host: www.it315.org:80 想要访问的虚拟主机名
	If-Modified-Since: Tue, 11 Jul 2000 18:23:51 GMT 这是和缓存相关的一个头，带着缓存资源的最后获取时间
	Referer: http://www.it315.org/index.jsp 这个头表示当前的请求来自哪个链接，这个头和防盗链的功能相关
	User-Agent: Mozilla/4.0 (compatible; MSIE 5.5; Windows NT 5.0) 客户端的一些基本信息
	Cookie 会在后面讲会话技术的时候单讲
	Connection: close/Keep-Alive 指定是否继续保持连接
	Date: Tue, 11 Jul 2000 18:23:51 GMT 当前时间
### Http响应

**一个HTTP响应代表服务器向客户端回送的数据**，它包括： 一个状态行、若干消息头、以及实体内容 。

####  状态行

HTTP/1.1 200 OK
格式： HTTP版本号　状态码　原因叙述
状态码：
			200：请求处理成功
			302：请求重定向
			304、307：服务器通知浏览器使用缓存
			404：资源未找到
			500：服务器端错误

| 状态码  | 含义                                                         |
| ------- | ------------------------------------------------------------ |
| 100~199 | 表示成功接收请求，要求客户端继续提交下一次请求才能完成整个处理过程 |
| 200~299 | 表示成功接收请求已完成整个处理，常用200                      |
| 300~399 | 未完成请求客户需要进一步细化请求，例如请求重定向，301        |
| 400~499 | 客户端的请求有错误，常用404                                  |
| 500~599 | 服务器端出现错误，常用500                                    |

#### 若干响应头(response)

	Location: http://www.it315.org/index.jsp  配合302实现请求重定向
	Server:apache tomcat 服务器的基本信息
	Content-Encoding: gzip 服务器发送数据时使用的压缩格式
	Content-Length: 80 发送数据的大小
	Content-Language: zh-cn 发送的数据使用的语言环境
	Content-Type: text/html; charset=GB2312 当前所发送的数据的基本信息，（数据的类型，所使用的编码，用于定义网络文件的类型和网页的编码，决定浏览器将以什么形式、什么编码读取这个文件，这就是经常看到一些网页点击的结果却是下载一个文件或一张图片的原因）
	Last-Modified: Tue, 11 Jul 2000 18:23:51 GMT 缓存相关的头
	Refresh: 1;url=http://www.it315.org 通知浏览器进行定时刷新，此值可以是一个数字指定多长时间以后刷新当前页面，这个数字之后也可以接一个分号后跟一个URL地址指定多长时间后刷新到哪个URL
	Content-Disposition: attachment;filename=aaa.zip 与下载相关的头
	Transfer-Encoding: chunked 传输类型，如果是此值是一个chunked说明当前的数据是一块一块传输的
	Set-Cookie:SS=Q0=5Lb_nQ; path=/search 和cookie相关的头，后面课程单讲
	ETag: W/"83794-1208174400000" 和缓存机制相关的头
	Expires: -1 指定资源缓存的时间，如果取值为0或-1浏览就不缓存资源
	Cache-Control: no-cache  缓存相关的头，如果为no-cache则通知浏览器不缓存
	Pragma: no-cache   缓存相关的头，如果为no-cache则不缓存
	以上三个头都是用来控制缓存的，是因为历史原因造成的，不同的浏览器认识不同的头，我们通常三个一起使用保证通用性。
	Connection: close/Keep-Alive   是否保持连接
	Date: Tue, 11 Jul 2000 18:23:51 GMT 当前时间
[![cetf4P.png](https://z3.ax1x.com/2021/04/02/cetf4P.png)](https://imgtu.com/i/cetf4P)

## HTTPS

HTTPS （全称：Hyper Text Transfer Protocol over SecureSocket Layer），是以安全为目标的 HTTP 通道，在HTTP的基础上通过传输加密和[身份认证](https://baike.baidu.com/item/身份认证/5294713)保证了传输过程的安全性 [1]  。HTTPS 在HTTP 的基础下加入[SSL](https://baike.baidu.com/item/SSL/320778)，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL。 HTTPS 存在不同于 HTTP 的默认端口及一个加密/身份验证层（在 HTTP与 [TCP](https://baike.baidu.com/item/TCP/33012) 之间）。这个系统提供了身份验证与加密通讯方法。它被广泛用于[万维网](https://baike.baidu.com/item/万维网/215515)上安全敏感的通讯，例如交易支付等方面 （来源于：百度百科）

### **为什么出现https呢？**

在http请求都是通过明文请求的而不法分子很容易通过抓包工具获取到我们在网络间传输的信息。想象我们在支付时银行卡密码通过明文在网络间传输那是不是风险很大。为了解决这个问题，Netscape 公司制定了HTTPS协议，HTTPS可以将数据加密传输，也就是传输的是密文，即便黑客在传输过程中拦截到数据也无法破译，这就保证了网络通信的安全。

**要想了解 HTTPS 为何安全，还得继续了解一下这些概念：明文，密文，密钥 ，加密算法、摘要算法、数字签名和数字证书。**

**明文**： 明文指的是未被加密过的原始数据。
**密文**：明文被某种加密算法加密之后，会变成密文，从而确保原始数据的安全。密文也可以被解密，得到原始的明文。
**密钥**：密钥是一种参数，它是在明文转换为密文或将密文转换为明文的算法中输入的参数。密钥分为对称密钥与非对称密钥，分别应用在对称加密和非对称加密上。

### 加密算法

#### **对称密钥密码体制**

对称密钥密码体制，即加密密钥和解密密钥是使用相同的密码体制。对称密钥加密技术的缺点之一就是发送者和接收者在对话之前，一定要有一个共享的密钥，所以不太安全。双方必须协商一个保密的密钥。

其加密过程如下：**明文 + 加密算法 + 私钥 => 密文**
 解密过程如下：   **密文 + 解密算法 + 私钥 => 明文**

对称加密中用到的密钥叫做私钥，私钥表示个人私有的密钥，即该密钥不能被泄露。
 其加密过程中的私钥与解密过程中用到的私钥是同一个密钥，这也是称加密之所以称之为“对称”的原因。由于对称加密的算法是公开的，所以一旦私钥被泄露，那么密文就很容易被破解，所以对称加密的缺点是密钥安全管理困难。加密解密算法需要密钥双方必须知道，但密钥无法通过网络进行发送。这样又有问题了。

[![cnzJEt.png](https://z3.ax1x.com/2021/04/03/cnzJEt.png)](https://imgtu.com/i/cnzJEt)

#### **公钥密码体制（非对称加密） RSA**

公钥密码体制非对称加密）使用不同的加密密钥与解密密钥。公钥密码体制产生的主要原因有两个：一是对称密钥密码体制的密钥分配问题，二是对数字签名的需求。

在公钥密码体制（非对称加密）中不必双方协商一个保密的密钥，而是有一对钥匙，一个是保密的，称为私钥；另一个是公开的，称为公钥。

在公钥密码体制非对称加密）中，加密密钥是公开的，解密密钥(私钥)是需要保密的，加密算法和解密算法也是公开的。

公钥密码体制非对称加密）的加密和解密有如下特点：

**用私钥加密的数据，只有对应的公钥才能解密；用公钥加密的数据，只有对应的私钥才能解密。**

[![cuC0J0.png](https://z3.ax1x.com/2021/04/03/cuC0J0.png)](https://imgtu.com/i/cuC0J0)

**密钥对产生器**产生出接收者 B 的一对密钥，即加密密钥 PK 和解密密钥 SK。发送者 A 用 B 的公钥 PK 作为加密密钥来加密信息，B 接收后用解密密钥 SK 解密。

使用对称密钥时，由于双方使用同样的密钥，因此在通信信道上可以进行一对一的双向保密通信，双方都可以用同一个密钥加密解密。

使用公开密钥时，在通信信道上可以是多对一的单向保密信道。即可以有多人持有 B 的公钥，但只有 B 才能解密。

[![cuiW26.png](https://z3.ax1x.com/2021/04/03/cuiW26.png)](https://imgtu.com/i/cuiW26)

**摘要算法**

摘要算法的主要特征是加密过程不需要密钥，并且经过加密的数据无法被解密，目前可以被解密逆向的只有CRC32算法，只有输入相同的明文数据经过相同的消息摘要算法才能得到相同的密文。

[![cuFCIs.png](https://z3.ax1x.com/2021/04/03/cuFCIs.png)](https://imgtu.com/i/cuFCIs)

**数字签名**

用加密系统对报文进行签名，以说明是谁编写的报文，同时证明报文未被篡改过，这种技术称为**数字签名**。

数字签名是附加在报文上的特殊加密校验码。使用数字签名的好处有：

签名可以证明是作者编写了这条报文。只有作者才会有最机密的私有密钥，因此，只有作者才能计算出这些校验和。签名可以防止报文被篡改，如果有人在报文传输过程中对其进行了修改，校验和就不再匹配了。数字签名通常是用非对称公开密钥技术产生的。

![img](https://pics4.baidu.com/feed/279759ee3d6d55fb091dbbe00771574222a4ddfd.jpeg?token=e7c500b51f53e9430fa5fb8e5b81aec4&s=1AAA7A23BBAC6C035C5DB0D20000C0B1)

看上图，任何人都能用 A 的公钥 PK 对密文进行 E 运算后得到 A 发送的明文。可见这种通信并非为了保密，而是为了进行签名和核实签名，即确认此信息是 A 发送的（使用 A 的密钥进行加密的报文，只有使用 A 的公钥才能正确解密）。 但上述过程仅对报文进行了签名，对报文 X 本身却未保密，所以要采用下图的方法，同时实现秘密通信和数字签名。

![img](https://pics4.baidu.com/feed/7acb0a46f21fbe09cbc6d2da0233143b8644ad3b.jpeg?token=1367b3bce22351dd015ff3c6828abe73&s=1AA87A228FD844CA1C5590C60000E0B1)

**数字证书**

假如你想访问一个网站，怎么确保对方给你的公钥是你想访问的网站的公钥，而不是被中间人篡改过的？

数字证书的出现就是为了解决这个问题，它是由数字证书认证机构颁发的，用来证明公钥拥有者的身份。换句话说，数字证书的作用就相当于人的身份证，身份证证明了张三就是张三，而不是别人。

**数字证书一般包含以下内容**：

对象的名称（人、服务器、组织等）；过期时间；证书发布者（由谁为证书担保）；来自证书发布者的数字签名；对象的公钥；对象和所用签名算法的描述性信息。任何人都可以创建一个数字证书，但由谁来担保才是重点。

**数字证书的数字签名计算过程**：

用摘要算法对数字证书的内容计算出摘要；用数字证书的私钥对摘要进行加密得到数字签名。

![img](https://pics0.baidu.com/feed/267f9e2f07082838be9b1f2bd2cab1094d08f1d3.jpeg?token=470c61ae6abdb997e56bcca1ae028cc5&s=780C34720BC840494CF561DE0000C0B1)

当浏览器收到证书时，会对签名颁发机构进行验证，如果颁发机构是个很有权威的公共签名机构，浏览器可能就知道其公开密钥了（浏览器会预装很多签名颁发机构的证书）。如果对签名颁发机构一无所知，浏览器通常会向用户显示一个对话框，看看他是否相信这个签名发布者。

因为数字证书的公钥是公开的，任何人都可以用公钥解密出数字证书的数字签名的摘要，然后再用同样的摘要算法对证书内容进行摘要计算，将得出的摘要和解密后的摘要作对比，如果内容一致则说明这个证书没有被篡改过，可以信任。

这个过程是建立在被大家所认可的证书机构之上得到的公钥，所以这是一种安全的方式。

![img](https://pics3.baidu.com/feed/2cf5e0fe9925bc31cf2fb32c368c95b9ca1370eb.jpeg?token=e7790f915cdf3d8db287d67ad70db3f6&s=7E28346313CF614B4AFC40DA0000C0B1)

### Http整个流程

**一个HTTPS请求实际上包含了两次HTTP传输，可以细分为8步。**

[![cuEneS.png](https://z3.ax1x.com/2021/04/03/cuEneS.png)](https://imgtu.com/i/cuEneS)

1.客户端向服务器发起HTTPS请求，连接到服务器的443端口

2.服务器端有一个密钥对，即公钥和私钥，是用来进行非对称加密使用的，服务器端保存着私钥，不能将其泄露，公钥可以发送给任何人。

3.服务器将自己的公钥发送给客户端。

4.客户端收到服务器端的证书之后，会对证书进行检查，验证其合法性，如果发现发现证书有问题，那么HTTPS传输就无法继续。严格的说，这里应该是验证服务器发送的数字证书的合法性，关于客户端如何验证数字证书的合法性，下文会进行说明。如果公钥合格，那么客户端会生成一个随机值，这个随机值就是用于进行对称加密的密钥，我们将该密钥称之为client key，即客户端密钥，这样在概念上和服务器端的密钥容易进行区分。然后用服务器的公钥对客户端密钥进行非对称加密，这样客户端密钥就变成密文了，至此，HTTPS中的第一次HTTP请求结束。

5.客户端会发起HTTPS中的第二个HTTP请求，将加密之后的客户端密钥发送给服务器。

6.服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文。

7.然后服务器将加密后的密文发送给客户端。

8.客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。这样HTTPS中的第二个HTTP请求结束，整个HTTPS传输完成。

参考：《码农翻身》

参考：《菜鸟教程》

## Request与Response

### Request

request这个对象不用事先声明，就可以在JSP网页中使用，在编译为Servlet之后，它会转换为javax.servlet.http.HttpServletRequest形态的对象，HttpServletRequest对象是有关于客户端所发出的请求的对象，只要是有关于客户端请求的信息，都可以藉由它来取得，例如请求标头、请求方法、请求参数、客户端IP，客户端浏览器等等信息

**ServletRequest -- 通用request，提供一个request应该具有的最基本的方法.HttpSerletRequest是Rquest的子类针对http协议进行了进一步的增强**

#### Request的操作

##### 获取客户机信息

  getRequestURL方法返回客户端发出请求完整URL
  getRequestURI方法返回请求行中的资源名部分
  getQueryString 方法返回请求行中的参数部分
  getRemoteAddr方法返回发出请求的客户机的IP地址
   getMethod得到客户机请求方式
   getContextPath 获得当前web应用虚拟目录名称

##### 获取请求头信息

获得客户机请求头
      getHeader(name)方法 --- String 
      getHeaders(String name)方法 --- Enumeration<String>枚举变量<string类型的>
      getHeaderNames方法 --- Enumeration<String>
获得具体类型客户机请求头
       getIntHeader(name)方法  --- int
       getDateHeader(name)方法 --- long(日期对应毫秒)

##### 获取请求参数

request.getParameter()

 浏览器以什么编码来发送请求参数? 浏览器以什么编码打开的表单页面,就用什么编码发送这个页面提交的数据。服务器以什么编码来打开呢?如果不指定,则使用ISO8859-1,这样如果请求参数中有中文必然就乱码了
对于POST提交,可以设置request.setCharacterEncoding("utf-8");明确的通知服务器以浏览器发送过来的编码来打开数据就可以解决乱码但是上面的方法只对请求中实体内容部分起作用,所以GET提交的乱码并不能解决.
 对于GET提交的乱码,只能手动的进行编解码从而解决乱码问题:
            String username = request.getParameter("username");
	 username = new String(username.getBytes("iso8859-1"),"utf-8");

##### 利用请求域传递对象

  作用范围:整个请求链上
        生命周期:当服务器收到一个请求,创建出代表请求的request对象,request开始.当请求结束,服务器销毁代表请求的request对象,request域结束.
        作用:在整个请求链范围内共享数据,通常我们在Servlet中处理好的数据会存入request域后请求转发到jsp页面来进行展示

        setAttribute
        getAttribute
        removeAttribute
##### 实现请求转发和请求包含

  (1)请求转发(.forward()):
            this.getServletContext().getRequestDispatcher("").forward(request,response);
            request.getRequestDispatcher("").forward(request,response); 

    请求转发是希望将请求交给另外一个资源执行,所以应该保证只有最后真正要执行的资源才能够输出数据,所以:
    请求转发时,如果已经有数据被写入到了response的缓冲区,但是这些数据还没有被发送到客户端,则请求转发时,这些数据将会被清空.但是清空的只是响应中的实体内容部分,头信息并不会被清空.
    而请求转发时已经有数据被打给了浏览器,那么再进行请求转发,不能成功,会抛出异常,原因是响应已经结束了,再转发交给其他人没意义了
    在最终输出数据的Servlet执行完成后,response实体内容中的数据将会被设置为已提交的状态,再往里写数据也不会起作用
   (2)请求包含(.include()):将两个资源的输出进行合并后输出多个资源同是输出
            this.getServletContext().getRequestDispatcher("").include(request,response);
            request.getRequestDispatcher("").include(request,response);

    被包含的Servlet程序不能改变响应消息的状态码和响应头，如果它里面存在这样的语句，这些语句的执行结果将被忽略常被用来进行页面布局
  (3)三种资源处理方式的区别
            请求重定向
                response.sendRedirect();
            请求转发
                request.getRequestDispatcher().forward();
            请求包含
                request.getRequestDispatcher().include();

    请求重定向和请求转发的区别:
        请求重定向地址栏会发生变化.请求转发地址栏不发生变化.
        请求重定向两次请求两次响应.请求转发一次请求一次响应.
                
        如果需要在资源跳转时利用request域传递域属性则必须使用请求转发 request.getRequestDispatcher().forward();
        如果希望资源跳转后修改用户的地址栏则使用请求重定向response.sendRedirect();
        如果使用请求转发也可以重定向也可以,则优先使用请求转发,减少浏览器对服务器的访问次数减轻服务器的压力.
## Session与Cookie



## Servlet

### Servlet生命周期

### Servlet调用过程

### Servlet过滤器与监听器

### Servlert经典实例



